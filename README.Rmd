---
title: "Modeling antibiotic resistance in populations using a compartmental model"
output: github_document
Author: Arya Gautam
editor_options: 
  chunk_output_type: console
---
Here is the final model with populations A (high antibiotic use, high "immunity") and population B (low antibiotic use, low "immunity") in a 2-group structured model.

![](model_design.png)



In this compartmental model, the compartments are:

S = susceptible

I1 = infected with antibiotic use

I2 = infected with no antibiotic use

R1 = infected with resistant strain

C = asymptomatic carrier

R2 = asymptomatic carrier with resistant strain

M = immune


The parameters are defined as follows:

c = contact rate (10 for within population and 5 for between populations)

p = probability of transmission (0.005)

a = probability of virulent infection (0.0002 for population A and 0.0004 for population B)

u = probability of antibiotic use (1 for population A and 0.5 for population B)

f = clearance rate in the absence of virulent infection (1/35)

e = recovery rate in case of virulent infection under antibiotic use (1/14)

g = recovery rate in case of virulent infection under no antibiotic use or antibiotic resistance (1/45)

r = probability of resistance emergence (3e-06)

```{r, message=FALSE, include=FALSE}
library(tidyverse) 
library(odin)
library(pkgbuild)
library(pkgload)
library(numDeriv)
library(rootSolve)
library(deSolve)
library(ggplot2)
library(tidyr)
library(dplyr)
```

```{r, echo=FALSE}
rhs_AB_sepN <- function(t, state, parms) {
  with(as.list(state), {

    # parameters 
    e    <- parms$e
    f    <- parms$f
    r    <- parms$r
    g    <- parms$g
    u    <- parms$u
    Mvec <- parms$M
    beta  <- as.matrix(parms$beta)
    betap <- as.matrix(parms$betap)
    alpha <- as.matrix(parms$alpha)

    # pack state into 2-vectors
    S  <-  c(SA,  SB)
    C  <-  c(CA,  CB)
    I1  <- c(I1A, I1B)
    I2  <- c(I2A, I2B)
    R1 <-  c(R1A, R1B)
    R2 <-  c(R2A, R2B)

    Nvec <- S + C + I1 + I2 + R1 + R2 + Mvec      
    ICN_vec <- (I1 + I2 + C) / Nvec               
    R1_vec  <- R1 / Nvec
    R2_vec  <- R2 / Nvec
    RN_vec  <- R1_vec + R2_vec
    RN_diag <- diag(RN_vec, 2, 2)
 
    inf_I1 <- as.vector(beta  %*% ICN_vec) * S * u
    inf_I2 <- as.vector(beta  %*% ICN_vec) * S * (1-u)
    inf_C <- as.vector(betap %*% ICN_vec) * S
    res_from_C       <- as.vector(alpha %*% (RN_diag %*% C))
    res_to_R1_from_S <- as.vector(beta  %*% (RN_diag %*% S))
    res_to_R2_from_S <- as.vector(betap %*% (RN_diag %*% S))
    res_from_I1       <- as.vector(alpha %*% (RN_diag %*% I1))
    res_from_I2       <- as.vector(alpha %*% (RN_diag %*% I2))

    dI1  <- inf_I1 - e*r*I1 - e*(1-r)*I1 - res_from_I1
    dI2  <- inf_I2 - g*I2 - res_from_I2
    dC   <- inf_C  - f*C - res_from_C
    
    dR1  <- res_to_R1_from_S + res_from_I2+ res_from_I1 + r*e*I1 - g*R1 
    dR2 <-  res_to_R2_from_S + res_from_C - f*R2 
    
    dS <- -inf_I1 - inf_I2 - inf_C - res_to_R1_from_S - res_to_R2_from_S +
           f*C + g*R1 + f*R2 + (1-r)*e*I1 + g*I2

    list(c(
  dSA  = dS[1],  dCA  = dC[1],  dI1A = dI1[1], dI2A = dI2[1], dR1A = dR1[1], dR2A = dR2[1],
  dSB  = dS[2],  dCB  = dC[2],  dI1B = dI1[2], dI2B = dI2[2], dR1B = dR1[2], dR2B = dR2[2]
))
 
  })
}

# Parameters
parms <- list(
  e = 1/14,
  f = 1/35,
  g = 1/45,
  r = 3e-6,
  M = c(0.10, 0.05),
  cW = 10,
  cB = 5,
  aA = 0.0002,
  aB = 0.0004,
  p  = 0.005,
  u  = c(1,0.5)
)

# Define alpha, beta, betap 
parms$beta <- with(parms, matrix(c(
  cW*aA*p, cB*aA*p,
  cB*aB*p, cW*aB*p
), 2, 2, byrow = TRUE))

parms$alpha <- with(parms, matrix(c(
  cW*p, cB*p,
  cB*p, cW*p
), 2, 2, byrow = TRUE))

parms$betap <- with(parms, matrix(c(
  cW*(1-aA)*p, cB*(1-aA)*p,
  cB*(1-aB)*p, cW*(1-aB)*p
), 2, 2, byrow = TRUE))

# Start state
state0 <- c(
  SA=0.38, CA=0.01, I1A=0.005, I2A=0.005, R1A=0.00, R2A=0.00,
  SB=0.43, CB=0.01, I1B=0.005, I2B=0.005, R1B=0.00, R2B=0.00
)

# run with the SAME parms/state0 as you already have:
times <- seq(0, 1095, by = 10)
out_sepN <- ode(y = state0, times = times, func = rhs_AB_sepN, parms = parms)

df <- as.data.frame(out_sepN)
df$MA <- parms$M[1]
df$MB <- parms$M[2]

df_long <- df %>%
  pivot_longer(-time, names_to="var", values_to="value") %>%
  mutate(group = ifelse(grepl("A$", var), "A", "B"),
         compartment = gsub("A$|B$", "", var))

ggplot(df_long, aes(x=time, y=value, color=compartment, linetype=group)) +
  geom_line(linewidth=1) +
  scale_color_manual(values=c("purple","black","hotpink","darkgreen","brown","red","dodgerblue")) +
  theme_minimal(base_size=13) +
  labs(x="Days", y="Proportion", color="Compartment", linetype="Group")

```

Equilibrium and stability analysis for the 2 group structured model
```{r,echo=FALSE}
## Equilibrium solver for two-group resistance model
parms <- list(
  e = 1/14,
  f = 1/35,
  g = 1/45,
  r = 3e-6,
  MA = 0.10,
  MB = 0.05,
  cW = 10,
  cB = 5,
  aA = 0.0002,
  aB = 0.0004,
  p = 0.005,
  uA = 1.0,
  uB = 0.5
)

# Pre-compute matrices
parms$beta <- with(parms, matrix(c(
  cW*aA*p, cB*aA*p,
  cB*aB*p, cW*aB*p
), 2, 2, byrow = TRUE))

parms$alpha <- with(parms, matrix(c(
  cW*p, cB*p,
  cB*p, cW*p
), 2, 2, byrow = TRUE))

parms$betap <- with(parms, matrix(c(
  cW*(1-aA)*p, cB*(1-aA)*p,
  cB*(1-aB)*p, cW*(1-aB)*p
), 2, 2, byrow = TRUE))

eq_fn <- function(x, parms) {
  SA <- x[1]; CA <- x[2]; I1A <- x[3]; I2A <- x[4]; R1A <- x[5] ; R2A <- x[6]
  SB <- x[7]; CB <- x[8]; I1B <- x[9]; I2B <- x[10]; R1B <- x[11]; R2B <- x[12]
  
  # Extract parameters
  e <- parms$e
  f <- parms$f
  g <- parms$g
  r <- parms$r
  MA <- parms$MA
  MB <- parms$MB
  uA <- parms$uA
  uB <- parms$uB
  beta <- parms$beta
  betap <- parms$betap
  alpha <- parms$alpha
  
  # Pack into vectors
  S <- c(SA, SB)
  C <- c(CA, CB)
  I1 <- c(I1A, I1B)
  I2 <- c(I2A, I2B)
  R1 <- c(R1A, R1B)
  R2 <- c(R2A, R2B)
  Mvec <- c(MA, MB)
  u <- c(uA, uB)
  
  # Calculate derived quantities
  Nvec <- S + C + I1 + I2 + R1 + R2 + Mvec
  ICN_vec <- (I1 + I2 + C) / Nvec
  R1_vec <- R1 / Nvec
  R2_vec <- R2 / Nvec
  RN_vec <- R1_vec + R2_vec
  RN_diag <- diag(RN_vec, 2, 2)
  
  # Infection rates
  inf_I1 <- as.vector(beta %*% ICN_vec) * S * u
  inf_I2 <- as.vector(beta %*% ICN_vec) * S * (1 - u)
  inf_C <- as.vector(betap %*% ICN_vec) * S
  
  # Resistance acquisition rates
  res_from_C <- as.vector(alpha %*% (RN_diag %*% C))
  res_to_R1_from_S <- as.vector(beta %*% (RN_diag %*% S))
  res_to_R2_from_S <- as.vector(betap %*% (RN_diag %*% S))
  res_from_I1 <- as.vector(alpha %*% (RN_diag %*% I1))
  res_from_I2 <- as.vector(alpha %*% (RN_diag %*% I2))
  
  # Differential equations
  dI1 <- inf_I1 - e*r*I1 - e*(1-r)*I1 - res_from_I1
  dI2 <- inf_I2 - g*I2 - res_from_I2
  dC <- inf_C - f*C - res_from_C
  dR1 <- res_to_R1_from_S + res_from_I2 + res_from_I1 + r*e*I1 - g*R1
  dR2 <- res_to_R2_from_S + res_from_C - f*R2
  dS <- -inf_I1 - inf_I2 - inf_C - res_to_R1_from_S - res_to_R2_from_S +
        f*C + g*R1 + f*R2 + (1-r)*e*I1 + g*I2
  
  # Mass balance constraint (should equal zero at equilibrium)
  mass_balance <- SA + MA + CA + I1A + I2A + R1A + R2A + 
                  SB + CB + I1B + I2B + R1B + R2B + MB - 1
  
  # Return 12 equations (11 differential equations + 1 constraint)
   c(mass_balance, dC[1], dI1[1], dI2[1], dR1[1], dR2[1],
    dS[2], dC[2], dI1[2], dI2[2], dR1[2], dR2[2])
}
```

```{r, echo=FALSE}
## Find equilibrium from a single starting point
x_start <- c(SA=0.10, CA=0.00, I1A=0.000, I2A=0.000, R1A=0.000, R2A=0.30,
             SB=0.10, CB=0.00, I1B=0.000, I2B=0.000, R1B=0.000, R2B=0.35) #starting close to endemic equilibirium

eq <- multiroot(f = eq_fn, start = x_start, parms = parms)
cat("Steady state for endemic equilibrium:\n")
cat(paste(names(eq$root), round(eq$root, 6), sep = " = ", collapse = "\n"), "\n")

#Population B has a higher proportion of people who are resistant carriers in the steady state! 

##Stability
eq_point <- as.numeric(eq$root)
jac <- jacobian(func = eq_fn, x = eq_point, parms = parms)
cat("The eigenvalues of the jacobian calculated at the steady state calculated above are:\n")
cat(eigen(jac)$values)

#The steady state is not stable.
```
We can see that population B has a higher proportion of its population who carry resistant strains of Streptococcus Pneumonia in equilibrium conditions. However, we find that this is not a stable equilibrium.


We can also start at multiple randomly generated conditions and follow the trajectory numerically to assess steady states.
Here's what we get when we do that. 

```{r,echo=FALSE, warning=FALSE}
## Check with multiple random starting conditions
set.seed(42)
n_starts <- 50
starts <- replicate(n_starts, {
  # Split between groups A and B
  groupA_total <- 0.40
  groupB_total <- 0.45
  
  # Distribute within group A (INCLUDING SA)
  xA <- runif(6)  
  xA <- xA / sum(xA) * groupA_total
  
  # Distribute within group B
  xB <- runif(6)
  xB <- xB / sum(xB) * groupB_total
  
  x <- c(xA, xB)
  names(x) <- c("SA", "CA", "I1A", "I2A", "R1A", "R2A",  
                "SB", "CB", "I1B", "I2B", "R1B", "R2B")
  x
}, simplify = FALSE)

# Solve from each starting point AND keep the starting point
results <- lapply(1:length(starts), function(i) {
  st <- starts[[i]]
  out <- try(multiroot(eq_fn, start = st, parms = parms, maxiter = 1000), silent = TRUE)
  
  # Return both starting point and equilibrium
  list(
    start_id = i,
    start = st,
    equilibrium = out$root,
    converged = !inherits(out, "try-error")
  )
})

# Convert to dataframe
roots_df <- do.call(rbind, lapply(results, function(r) r$equilibrium))
roots_df <- as.data.frame(roots_df)
colnames(roots_df) <- c("SA","CA", "I1A", "I2A", "R1A", "R2A", 
                        "SB", "CB", "I1B", "I2B", "R1B", "R2B")

# Reshape for plotting
roots_long <- roots_df %>%
  pivot_longer(cols = everything(), names_to = "Compartment", values_to = "Proportion") %>%
  mutate(Group = ifelse(grepl("A$", Compartment), "Group A", "Group B"),
         Class = gsub("A$|B$", "", Compartment))

# Plot
ggplot(roots_long, aes(x = Class, y = Proportion, color = Group)) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
  facet_wrap(~Group) +
  ylim(0, 1.0) +
  theme_minimal(base_size = 13) +
  labs(title = "Equilibrium conditions from multiple starting points",
       subtitle = paste(nrow(roots_df), "successful convergences out of", n_starts, "attempts")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Oof! That's messy!

We can also model them as separate populations. 

First, let's look at population A

```{r,echo=FALSE, warning=FALSE}
#Population A
sir_model <- odin({
#Define total people
  N <- M + S + C + I1+ I2 + R1 + R2 
  
  # Define intermediate terms for clarity
  ICN <- (I1 + I2 + C) / N
  RN <- (R1 + R2) / N
  
  # Define the ODEs (each deriv must be a single expression)
  deriv(S) <- -c*p*ICN*a*S*u - c*p*ICN*a*S*(1-u) - c*p*ICN*S*(1-a) - c*p*RN*a*S - c*p*RN*(1-a)*S + f*C + g*R1 + f*R2 + (1-r)*I1*e + g*I2 
  
  deriv(C) <- -f*C - c*p*RN*C + c*p*ICN*S*(1-a)
  
  deriv(I1) <- c*p*ICN*a*S*u - r*I1*e - (1-r)*e*I1 - c*p*RN*I1
  
  deriv(I2) <- c*p*ICN*a*S*(1-u) - c*p*RN*I2 - g*I2
  
  deriv(R1) <- r*I1*e - g*R1 + c*p*RN*a*S + c*p*RN*I2 + c*p*RN*I1
  
  deriv(R2) <- -f*R2 + c*p*RN*C + c*p*RN*(1-a)*S
  
  deriv(M)  <- 0
  
  # define initial conditions: 
	initial(M) <- 0.10
	initial(S) <- 0.88
	initial(C) <- 0.01
	initial(I1) <- 0.01 
	initial(I2) <- 0.00
	initial(R1) <- 0.00
	initial(R2) <- 0.00
  
  c <- user(10) 
  a <- user(0.0002) 
  f <- user(1/35) 
  e <- user(1/14) 
  g <- user(1/45)
  u <- user(1)
  r <- user(3e-06) 
  p <- user(0.005)
})

# Generate the model
model <- sir_model$new()

# Run it
t <- seq(from=0, to=2190, by=10)
sol <- as_tibble(data.frame(model$run(t)))

end_labels <- sol %>% pivot_longer(-t) %>% group_by(name) %>% filter(t == max(t)) %>% ungroup()%>%
  mutate(
    y_jitter = value + seq(-0.02, 0.03, length.out = n())
  )

figure<- sol %>% 
	pivot_longer(-t) %>% 
	ggplot(aes(x=t, y=value, col=factor(name, levels=c("M","S","C","I1","I2","R1","R2")))) + 
	geom_line() + xlab("Days(t)")+ ylab("Proportion")+
  scale_color_manual(values=c("forestgreen","dodgerblue","purple","black","hotpink","brown","red"),
                     label=c("Immune","Susceptible","Carrier","Infected_antibiotics","Infected_no_antibiotics",
                             "Resistant_infeced","Resistant_carrier"))+
	theme_classic() + 
  geom_text(data = end_labels,
            aes(x = t, y = y_jitter, label = sprintf("%.2f", value)),hjust=0.4,size = 3,show.legend = FALSE)+
	theme(legend.title=element_blank())

figure

##Lets solve for equilibrium abundances numerically:
parms <- list(c=10, a=0.0002, f=1/35, e=1/14, g=1/45, r=3e-06, p=0.005, M=0.10, u=1.00)

eq_fn <- function(x, parms){
  S  <- x[1]; C <- x[2]; I1 <- x[3]; I2 <- x[4]; R1 <- x[5]; R2 <- x[6]
  with(parms, {
    N <- S + C + I1 + I2 + R1 + R2 + M
    ICN <- (I1 + I2 + C) / N
    RN <- (R1 + R2) / N
    
    dS  <- -c*p*ICN*a*S*u - c*p*ICN*a*S*(1-u) - c*p*ICN*S*(1-a) - c*p*RN*a*S - c*p*RN*(1-a)*S + f*C + g*R1 + f*R2 + (1-r)*I1*e + g*I2 
    dC  <- -f*C - c*p*RN*C + c*p*ICN*S*(1-a)
    dI1 <- c*p*ICN*a*S*u - r*I1*e - (1-r)*e*I1 - c*p*RN*I1
    dI2 <- c*p*ICN*a*S*(1-u) - c*p*RN*I2 - g*I2
    dR1 <- r*I1*e - g*R1 + c*p*RN*a*S + c*p*RN*I2 + c*p*RN*I1
    dR2 <- -f*R2 + c*p*RN*C + c*p*RN*(1-a)*S
    
    # Mass balance: fix the typo (I -> I1 + I2)
    mass <- S + C + I1 + I2 + R1 + R2 - (1 - M)
    
    # Return 6 equations: 5 ODEs + mass balance (drop dS as redundant)
    c(dC, dI1, dI2, dR1, dR2, mass)
  })
}

# Starting point
x_start <- c(S=0.60, C=0.00, I1=0.000, I2=0.000, R1=0.00, R2=0.30)
eq <- multiroot(f=eq_fn, start=x_start, parms=parms)
cat("Steady state for endemic equilibrium:\n")
cat(paste(names(eq$root), round(eq$root, 6), sep = " = ", collapse = "\n"), "\n")

#Stability
x_eq <- eq$root
J <- numDeriv::jacobian(func = eq_fn, x = x_eq, parms = parms)
eig <- eigen(J)$values
cat("The eigenvalues of the jacobian calculated at the steady state calculated above are:\n") #not stable!
cat(eig)
```
33% of the population end up as carriers of resistant strains of Streptococcus Pneumonia in population A. 
This steady state, however, isn't stable.

Similarly, starting at multiple random conditions give us these steady states

```{r,echo=FALSE, warning=FALSE}
##Check iteratively with many random starting conditions
set.seed(1)
starts <- replicate(30, {
  x <- runif(6)
  x <- x / sum(x) * (1 - parms$M)   # enforce sum=0.9
  names(x) <- c("S","C","I1","I2","R1","R2")
  x
}, simplify=FALSE)
roots <- lapply(starts, function(st){
  out <- try(multiroot(eq_fn, start=st, parms=parms)$root, silent=TRUE)
  if(inherits(out, "try-error")) return(rep(NA,5))
  out
})

#do.call(rbind, roots)
roots <- as.data.frame(roots)
roots <- as.data.frame(t(roots))
rownames(roots) <- seq(1:nrow(roots))
roots <- pivot_longer(roots,cols=1:6)
names(roots) <- c("Class","Proportion")
ggplot(roots,aes(x=Class,y=Proportion))+ geom_jitter()+ ylim(0,1.0)+ labs(title="Equilibirum conditions")
```

Now, for population B

```{r,echo=FALSE, warning=FALSE}
#Population B
sir_model <- odin({
#Define total people
  N <- M + S + C + I1+ I2 + R1 + R2 
  
  # Define intermediate terms for clarity
  ICN <- (I1 + I2 + C) / N
  RN <- (R1 + R2) / N
  
  # Define the ODEs (each deriv must be a single expression)
  deriv(S) <- -c*p*ICN*a*S*u - c*p*ICN*a*S*(1-u) - c*p*ICN*S*(1-a) - c*p*RN*a*S - c*p*RN*(1-a)*S + f*C + g*R1 + f*R2 + (1-r)*I1*e + g*I2 
  
  deriv(C) <- -f*C - c*p*RN*C + c*p*ICN*S*(1-a)
  
  deriv(I1) <- c*p*ICN*a*S*u - r*I1*e - (1-r)*e*I1 - c*p*RN*I1
  
  deriv(I2) <- c*p*ICN*a*S*(1-u) - c*p*RN*I2 - g*I2
  
  deriv(R1) <- r*I1*e - g*R1 + c*p*RN*a*S + c*p*RN*I2 + c*p*RN*I1
  
  deriv(R2) <- -f*R2 + c*p*RN*C + c*p*RN*(1-a)*S
  
  deriv(M)  <- 0
  
  # define initial conditions: 
	initial(M) <- 0.05
	initial(S) <- 0.93
	initial(C) <- 0.01
	initial(I1) <- 0.01 
	initial(I2) <- 0.00
	initial(R1) <- 0.00
	initial(R2) <- 0.00
  
  c <- user(10) 
  a <- user(0.0004) 
  f <- user(1/35) 
  e <- user(1/14) 
  g <- user(1/45)
  u <- user(0.5)
  r <- user(3e-06) 
  p <- user(0.005)
})

# Generate a specific odin instance: 
model <- sir_model$new() 

# Solve/simulate from this model: 
# First define some time points: 
t <- seq(from=0, to=2190, by=10)
sol <- as_tibble(data.frame(model$run(t)))

end_labels <- sol %>% pivot_longer(-t) %>% group_by(name) %>% filter(t == max(t)) %>% ungroup()%>%
  mutate(
    y_jitter = value + seq(-0.02, 0.03, length.out = n())
  )

figure<- sol %>% 
	pivot_longer(-t) %>% 
	ggplot(aes(x=t, y=value, col=factor(name, levels=c("M","S","C","I1","I2","R1","R2")))) + 
	geom_line() + xlab("Days(t)")+ ylab("Proportion")+
  scale_color_manual(values=c("forestgreen","dodgerblue","purple","black","hotpink","brown","red"),
                     label=c("Immune","Susceptible","Carrier","Infected_antibiotics","Infected_no_antibiotics",
                             "Resistant_infeced","Resistant_carrier"))+
	theme_classic() + 
  geom_text(data = end_labels,
            aes(x = t, y = y_jitter, label = sprintf("%.2f", value)),hjust=0.4,size = 3,show.legend = FALSE)+
	theme(legend.title=element_blank())

figure

##Lets solve for equilibrium abundances numerically:
parms <- list(c=10, a=0.0004, f=1/35, e=1/14, g=1/45, r=3e-06, p=0.005, M=0.05, u=0.50)

eq_fn <- function(x, parms){
  S  <- x[1]; C <- x[2]; I1 <- x[3]; I2 <- x[4]; R1 <- x[5]; R2 <- x[6]
  with(parms, {
    N <- S + C + I1 + I2 + R1 + R2 + M
    ICN <- (I1 + I2 + C) / N
    RN <- (R1 + R2) / N
    
    dS  <- -c*p*ICN*a*S*u - c*p*ICN*a*S*(1-u) - c*p*ICN*S*(1-a) - c*p*RN*a*S - c*p*RN*(1-a)*S + f*C + g*R1 + f*R2 + (1-r)*I1*e + g*I2 
    dC  <- -f*C - c*p*RN*C + c*p*ICN*S*(1-a)
    dI1 <- c*p*ICN*a*S*u - r*I1*e - (1-r)*e*I1 - c*p*RN*I1
    dI2 <- c*p*ICN*a*S*(1-u) - c*p*RN*I2 - g*I2
    dR1 <- r*I1*e - g*R1 + c*p*RN*a*S + c*p*RN*I2 + c*p*RN*I1
    dR2 <- -f*R2 + c*p*RN*C + c*p*RN*(1-a)*S
    
    # Mass balance: fix the typo (I -> I1 + I2)
    mass <- S + C + I1 + I2 + R1 + R2 - (1 - M)
    
    # Return 6 equations: 5 ODEs + mass balance (drop dS as redundant)
    c(dC, dI1, dI2, dR1, dR2, mass)
  })
}

# Starting point
x_start <- c(S=0.60, C=0.00, I1=0.000, I2=0.000, R1=0.00, R2=0.30)
eq <- multiroot(f=eq_fn, start=x_start, parms=parms)
cat("Steady state for endemic equilibrium:\n")
cat(paste(names(eq$root), round(eq$root, 6), sep = " = ", collapse = "\n"), "\n")

#Stability
x_eq <- eq$root
J <- numDeriv::jacobian(func = eq_fn, x = x_eq, parms = parms)
eig <- eigen(J)$values
cat("The eigenvalues of the jacobian calculated at the steady state calculated above are:\n") #not stable!
cat(eig)
```
38% of the population end up as carriers of resistant strains of Streptococcus Pneumonia in population A. 
This steady state is also not stable.

Starting at multiple random conditions give us these steady states

```{r,echo=FALSE, warning=FALSE}
##Check iteratively with many random starting conditions
set.seed(1)
starts <- replicate(30, {
  x <- runif(6)
  x <- x / sum(x) * (1 - parms$M)   # enforce sum=0.95
  names(x) <- c("S","C","I1","I2","R1","R2")
  x
}, simplify=FALSE)
roots <- lapply(starts, function(st){
  out <- try(multiroot(eq_fn, start=st, parms=parms)$root, silent=TRUE)
  if(inherits(out, "try-error")) return(rep(NA,5))
  out
})

#do.call(rbind, roots)
roots <- as.data.frame(roots)
roots <- as.data.frame(t(roots))
rownames(roots) <- seq(1:nrow(roots))
roots <- pivot_longer(roots,cols=1:6)
names(roots) <- c("Class","Proportion")
ggplot(roots,aes(x=Class,y=Proportion))+ geom_jitter()+ ylim(0,1.0)+ labs(title="Equilibirum conditions")
```

In conclusion, can see that population B, despite using antibiotics only 50% of the time that they get an infection with Streptococcus Pneumonia compared to population A who use it 100% of the times, end up with a higher proportion of its population who become carriers of resistant strains no matter how me model the system.
